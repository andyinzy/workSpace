## 学习思路
应该把时间主要花在知识的积累和对他人优秀思路的学习上，而非总是自己闷头搞个又丑又笨的解法，只有先积累到一定程度才能思考出好的方法。
其次，有压力才有效率，做题要限时定量。
**强烈建议配合晴神宝典（即《算法笔记》，胡凡、曾磊著）刷题**

## 取巧写法
sum_abs = (sum>=0) ? sum : -1*sum;


## 常见错误
- 输入字符串，注意'0'与0完全不同，一个是ASCII 48 ， 一个为0

## 考纲
考纲里要求掌握的算法为：哈希映射、并查集、最短路径、拓扑排序、关键路径、贪心、深度优先搜索、广度优先搜索、回溯剪枝等。

哈希映射：一般会用map和unordered_map就好。此外，比如说题目固定了关键字为4个大写字母，那么可以把关键字看成26进制数，这样就能把字符串转换为int型数据处理，提高程序运行速度。更新：当然基本概念也不能忘，解决哈希冲突的基础方法要理解，包括开放地址法（线性探测、平方探测）和链地址法（开放定址法）。并查集：主要就是掌握findfather函数（找到某节点所在集合的“根”）。压缩路径的函数如下：
```
int findfather(int a){
  if(a!=father[a]{
   father[a]=findfather(father[a]);
  }
  return father[a];
}
```
最短路径：主要掌握dijkstra+DFS。
如果出现了负边权，就用bellman-ford（尚未考过）。
拓扑排序、关键路径：可以做做PTA上的 Data Structures and Algorithms (English)题目集7-12和7-18，数据结构与算法题目集（中文）7-11。
贪心：考的很少。印象比较深的是甲级题库1033 To Fill or Not to Fill，挺难的。DFS、BFS：算是必须掌握的基础了。
回溯剪枝：就记得甲级题库里的1103了，不过因为内存限制放的宽，用动态规划暴力做也可以。此外，AVL树的插入删除要会写。

**根据树的各种遍历方式构建二叉树经常考到，最好熟练掌握。**

堆的构建、删除、插入要会写，即“自顶向下”和“自底向上”调整堆。